#!/usr/bin/env bash

IFS=$'\n'
DEFAULT_ERROR_LOG_FILE="errors"
DEFAULT_OUTPUT_DIR="output"

# Create temp directories for use in scripts
LOG_TEMP_DIR=$(mktemp --directory)
TEMP_DIR=$(mktemp --directory)

# Remove created temp files in unexpected exit
_trap_handler() {
    rm -rf "$LOG_TEMP_DIR"
    rm -rf "$TEMP_DIR"
}
trap _trap_handler EXIT

_msg_error() {
    local MESSAGE=$1

    # Check if the script is running in a terminal
    if env | grep -q '^TERM'; then
        echo >&2 "$MESSAGE"
    else # It doesn't use GUI notifications
        if hash notify-send 2>/dev/null; then
            notify-send -i error "$MESSAGE"
        elif hash zenity 2>/dev/null; then
            zenity --error --width=300 --text "$MESSAGE" &
        elif hash kdialog 2>/dev/null; then
            kdialog --title "$MESSAGE" --passivepopup "This popup will disappear in 5 seconds" 5 &
        elif hash xmessage 2>/dev/null; then
            xmessage "$MESSAGE" -timeout 5
        fi
    fi
}

_msg_info() {
    local MESSAGE=$1

    # Check if the script is running in a terminal
    if env | grep -q '^TERM'; then
        echo "$MESSAGE"
    else # If not, use GUI notifications
        if hash notify-send 2>/dev/null; then
            notify-send "$MESSAGE"
        elif hash zenity 2>/dev/null; then
            zenity --info --width=300 --text "$MESSAGE" &
        elif hash kdialog 2>/dev/null; then
            kdialog --title "$MESSAGE" --passivepopup "This popup will disappear in 5 seconds" 5 &
        elif hash xmessage 2>/dev/null; then
            xmessage "$MESSAGE" -timeout 5
        fi
    fi
}

_check_dependencies() {
    local LIST_COMMANDS=$*
    local PACKAGE_NAME
    local COMMAND

    for COMMAND in $LIST_COMMANDS; do
        if hash "$COMMAND" 2>/dev/null; then
            continue
        fi

        case "$COMMAND" in
        "7z")
            PACKAGE_NAME="p7zip-full"
            ;;
        "ar")
            PACKAGE_NAME="binutils"
            ;;
        "cmp")
            PACKAGE_NAME="diffutils"
            ;;
        "convert")
            PACKAGE_NAME="imagemagick"
            ;;
        "gpg")
            PACKAGE_NAME="gnupg"
            ;;
        "gs")
            PACKAGE_NAME="ghostscript"
            ;;
        "iconv")
            PACKAGE_NAME="libc-bin"
            ;;
        "lpr")
            PACKAGE_NAME="cups"
            ;;
        "pdffonts" | "pdfimages" | "pdfseparate" | "pdftoppm" | "pdftotext" | "pdfunite")
            PACKAGE_NAME="poppler-utils"
            ;;
        "pdfjam")
            PACKAGE_NAME="texlive-extra-utils"
            ;;
        "perl")
            PACKAGE_NAME="perl-base"
            ;;
        "photorec")
            PACKAGE_NAME="testdisk"
            ;;
        esac

        if [ -n "$PACKAGE_NAME" ]; then
            _msg_error "Error: The command '$COMMAND' was not found. You need to install the '$PACKAGE_NAME' package."
        else
            _msg_error "Error: The command '$COMMAND' was not found. Please, install it."
        fi
        return 1
    done

    return 0
}

_get_filename_without_extension() {
    local FILENAME=$1
    echo "$FILENAME" | sed -r "s|(\.tar){0,1}\.\w*$||"
}

_log_error() {
    local ERROR_TYPE=$1
    local FILENAME=$2
    local STD_OUTPUT=$3
    local OUTPUT_DIR=$4
    local LOG_TEMP_FILE

    LOG_TEMP_FILE=$(mktemp --tmpdir="$LOG_TEMP_DIR")

    {
        echo "[$(date "+%Y-%m-%d %H:%M:%S")] ERROR while processing '$FILENAME'."
        echo -e "\tType: $ERROR_TYPE."
        echo -e "\tStandard output: $STD_OUTPUT"
        echo ""
    } >"$LOG_TEMP_FILE"
}

_log_error_result() {
    local FILENAME=$1
    local STD_OUTPUT=$2
    local OUTPUT_DIR=$3
    local EXIT_CODE=$4
    local OUTPUT_FILE=$5 # To check if output file has zero bytes

    # Check the 'EXIT_CODE' and log the error
    if [ "$EXIT_CODE" -ne 0 ]; then
        _log_error "Exit code error" "$FILENAME" "$STD_OUTPUT" "$OUTPUT_DIR"
        return 1
    fi

    # Check if there is the word "Error" in stdout
    if [[ "${STD_OUTPUT,,}" == *"error"* ]]; then
        if [[ "${FILENAME,,}" != *"error"* ]]; then
            _log_error "Error in output message" "$FILENAME" "$STD_OUTPUT" "$OUTPUT_DIR"
            return 1
        fi
    fi

    # Check if output file exists
    if [[ -n "$OUTPUT_FILE" ]] && ! [ -f "$OUTPUT_FILE" ]; then
        _log_error "Output not exists" "$FILENAME" "$STD_OUTPUT" "$OUTPUT_DIR"
        return 1
    fi

    # Check if output file is not a zero byte
    if [ "$(stat --printf="%s" "$OUTPUT_FILE")" == "0" ]; then
        _log_error "Zero byte file" "$FILENAME" "$STD_OUTPUT" "$OUTPUT_DIR"
        return 1
    fi

    return 0
}

_display_result_tasks() {
    local OUTPUT_DIR=$1
    local OUTPUT_DIR_PRINT="$OUTPUT_DIR"
    local ERROR_LOG_FILE="$OUTPUT_DIR/$DEFAULT_ERROR_LOG_FILE.log"

    # If there is a 'errors.log' directory or file,
    # try to use 'errors (1).log', 'errors (2).log', ...
    local SUFFIX=0
    while [ -a "$ERROR_LOG_FILE" ]; do
        SUFFIX=$((SUFFIX + 1))
        ERROR_LOG_FILE="$OUTPUT_DIR/$DEFAULT_ERROR_LOG_FILE ($SUFFIX).log"
    done

    # Compile log errors in a single file
    if ls "$LOG_TEMP_DIR/"* &>/dev/null; then
        cat "$LOG_TEMP_DIR/"* >"$ERROR_LOG_FILE"
    fi

    # Print a simplified $OUTPUT_DIR to the user
    if [[ "$OUTPUT_DIR_PRINT" == *"/$DEFAULT_OUTPUT_DIR"* ]]; then
        OUTPUT_DIR_PRINT="./$DEFAULT_OUTPUT_DIR"
    elif [[ "$OUTPUT_DIR_PRINT" == "$HOME"* ]]; then
        OUTPUT_DIR_PRINT="~${OUTPUT_DIR_PRINT#"$HOME"}"
    fi

    # Check if there was some error
    if [ -f "$ERROR_LOG_FILE" ]; then
        _msg_error "Task finished with errors! See the '$OUTPUT_DIR_PRINT/$ERROR_LOG_FILE' for details."
        return 1
    fi

    # If OUTPUT_DIR parameter is defined
    if [ -n "$OUTPUT_DIR" ]; then
        # Try to remove the output directory (if it is empty)
        rmdir "$OUTPUT_DIR" &>/dev/null

        # Check if output directory still exists
        if [ -d "$OUTPUT_DIR" ]; then
            _msg_info "Task finished! The output files is in '$OUTPUT_DIR_PRINT' directory."
        else
            _msg_info "Task finished, but there is no output files!"
        fi
    else
        _msg_info "Task finished!"
    fi
}

_display_password_box() {
    local PASSWORD
    PASSWORD=$(zenity --password --title="Password" 2>/dev/null) || return 1

    if [[ -z "$PASSWORD" ]]; then
        _msg_error "Error: you must set a password!"
        return 1
    fi

    echo "$PASSWORD"
}

_display_info_box() {
    local MESSAGE=$1
    local TITLE=$2
    local LEN_TEXT
    local WIDTH_WINDOW

    if [[ -z "$MESSAGE" ]]; then
        MESSAGE="(Empty result)"
    fi

    LEN_TEXT=${#MESSAGE}

    WIDTH_WINDOW=$((LEN_TEXT * 10))
    if ((WIDTH_WINDOW > 1300)); then
        WIDTH_WINDOW=1300
    elif ((WIDTH_WINDOW < 300)); then
        WIDTH_WINDOW=300
    fi

    echo "$MESSAGE" | zenity --text-info --no-wrap --font="Liberation Mono" --height=300 --width="$WIDTH_WINDOW" --title "$TITLE" &
}

_get_output_dir() {
    local DIR_BASE="$PWD"
    local OUTPUT_DIR

    # Check directories available to put the 'output' dir
    [[ ! -w "$DIR_BASE" ]] && DIR_BASE="$HOME"
    [[ ! -w "$DIR_BASE" ]] && DIR_BASE="/tmp"
    OUTPUT_DIR="$DIR_BASE/$DEFAULT_OUTPUT_DIR"

    if [[ ! -w "$DIR_BASE" ]]; then
        _msg_error "Error: Could not find a directory with write permissions."
        return 1
    fi

    # If there is a 'output' directory or file,
    # try to use 'output (1)', 'output (2)', ...
    local SUFFIX=0
    while [ -a "$OUTPUT_DIR" ]; do
        SUFFIX=$((SUFFIX + 1))
        OUTPUT_DIR="$DIR_BASE/$DEFAULT_OUTPUT_DIR ($SUFFIX)"
    done

    mkdir -p "$OUTPUT_DIR"
    echo "$OUTPUT_DIR"

    return 0
}

_get_files() {
    local INPUT_FILES=$1 # Input list
    local MIME_LIST=$2   # Filter by MIME type
    local MIN_FILES=$3   # Minimum number of valid files
    local MAX_FILES=$4   # Maximum number of valid files
    local DIRECTORY_FLAG=$5
    # DIRECTORY_FLAG values:
    # "d": Include directories.
    # "r": Expand directories recursively (include only files).
    # "R": Expand directories recursively (include files + subdirectories).
    # empty: Ignore directories.

    local FILE
    local INPUT_FILES_NEW
    local MIME_FILE
    local MIME
    local OUTPUT_FILES
    local VALID_FILE=0
    local VALID_FILES_COUNT=0

    # Expand files in directories recursively
    if [ "$DIRECTORY_FLAG" = "r" ] || [ "$DIRECTORY_FLAG" = "R" ]; then
        for FILE in $INPUT_FILES; do
            if [ "$DIRECTORY_FLAG" = "r" ]; then
                INPUT_FILES_NEW+=$(find -L "$FILE" -type f ! -path "*.git/*")
            else
                INPUT_FILES_NEW+=$(find -L "$FILE" -depth ! -path "*.git/*")
            fi
            INPUT_FILES_NEW+=$'\n'
        done
        INPUT_FILES="$INPUT_FILES_NEW"
    fi

    # Checks if each file is valid
    for FILE in $INPUT_FILES; do
        VALID_FILE=0

        # Filter files by mime type
        if [ -n "$MIME_LIST" ]; then
            MIME_FILE=$(file --mime-type -b "$FILE")
            IFS_OLD=$IFS
            IFS=";"
            for MIME in $MIME_LIST; do
                [[ "$MIME_FILE" == *"$MIME"* ]] && VALID_FILE=1
            done
            IFS=$IFS_OLD
        else
            VALID_FILE=1
        fi

        # Check the DIRECTORY_FLAG
        if [ -z "$DIRECTORY_FLAG" ]; then
            [ -d "$FILE" ] && VALID_FILE=0
        fi

        # Add the file in the list if it is valid
        if ((VALID_FILE == 1)); then
            VALID_FILES_COUNT=$((VALID_FILES_COUNT + 1))
            OUTPUT_FILES+="$FILE"
            OUTPUT_FILES+=$'\n'
        fi
    done

    # Check if there is at last one file with valid mime type
    if ((VALID_FILES_COUNT == 0)); then
        if [ -n "$MIME_LIST" ]; then
            _msg_error "Error: There is no '$MIME_LIST' in the selected files!"
        else
            _msg_error "Error: There is no valid itens in the in the selected files!"
        fi
        return 1
    fi

    if [ -n "$MIN_FILES" ]; then
        if ((VALID_FILES_COUNT < MIN_FILES)); then
            _msg_error "Error: You selected $VALID_FILES_COUNT files, but the minium is $MIN_FILES!"
            return 1
        fi
    fi

    if [ -n "$MAX_FILES" ]; then
        if ((VALID_FILES_COUNT > MAX_FILES)); then
            _msg_error "Error: You selected $VALID_FILES_COUNT files, but the maximum is $MAX_FILES!"
            return 1
        fi
    fi

    echo "$OUTPUT_FILES" | grep -v "^$"
    return 0
}

_transfer_file() {
    local TRANSFER_FLAG=$1
    # TRANSFER_FLAG values:
    # "m": Move/rename.
    # "c": Copy.
    local FILE_SRC=$2
    local FILE_DST=$3
    local EXIT_CODE

    # Add the './' prefix
    if ! [[ "$FILE_SRC" == "/"* ]] && ! [[ "$FILE_SRC" == "./"* ]] && ! [[ "$FILE_SRC" == "." ]]; then
        FILE_SRC="./$FILE_SRC"
    fi
    if ! [[ "$FILE_DST" == "/"* ]] && ! [[ "$FILE_DST" == "./"* ]] && ! [[ "$FILE_DST" == "." ]]; then
        FILE_DST="./$FILE_DST"
    fi

    # Avoid transfer a file to the same name
    if [ "$FILE_SRC" = "$FILE_DST" ]; then
        return 0
    fi

    # Avoid overwrite a file. If there is the same name,
    # try to use the name 'file (1)', 'file (2)', ...
    if [[ "$FILE_DST" != "." ]]; then
        local FILE_DST_NEW
        local SUFFIX=0
        FILE_DST_NEW="$FILE_DST"
        while [ -a "$FILE_DST_NEW" ]; do
            SUFFIX=$((SUFFIX + 1))
            FILE_DST_NEW="$FILE_DST ($SUFFIX)"
        done
        FILE_DST="$FILE_DST_NEW"
    fi

    # Run the main process
    case "$TRANSFER_FLAG" in
    "m")
        mv "$FILE_SRC" "$FILE_DST"
        ;;
    "c")
        cp -a "$FILE_SRC" "$FILE_DST"
        ;;
    *)
        echo "Wrong parameters for '_transfer_file'."
        return 1
        ;;
    esac
    EXIT_CODE=$?

    # Check if the file has transferred
    if [ "$EXIT_CODE" -eq 0 ] && ! [ -a "$FILE_SRC" ] && [ -a "$FILE_DST" ]; then
        echo "Transferred '$FILE_SRC' to '$FILE_DST'."
    fi

    return "$EXIT_CODE"
}

_run_parallel_tasks() {
    local INPUT_FILES=$1

    export LOG_TEMP_DIR
    export DATA
    export TEMP_DIR
    export -f _check_dependencies
    export -f _get_filename_without_extension
    export -f _log_error
    export -f _log_error_result
    export -f _main_task
    export -f _msg_error
    export -f _msg_info
    export -f _transfer_file
    echo "$INPUT_FILES" | xargs --delimiter="\n" --max-procs="$(nproc --all --ignore=1)" --replace="{}" bash -c "_main_task \"{}\" \"$OUTPUT_DIR\""
}
